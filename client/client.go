// Package client provides a high-level client library for interacting with castletown
// sandboxed code execution service. It supports both HTTP REST and gRPC protocols.
package client

import (
	"context"
	"time"

	pb "github.com/joshjms/castletown/proto"
)

// Client is the unified interface for interacting with castletown service.
// It supports both HTTP REST and gRPC protocols through different implementations.
type Client interface {
	// Execute submits a job for execution and returns the results.
	// If req.ID is empty, a unique ID will be generated by the server.
	Execute(ctx context.Context, req *ExecRequest) (*ExecResponse, error)

	// Done notifies the server that the job is complete and can be cleaned up.
	// This is optional but recommended to free up resources on the server.
	Done(ctx context.Context, jobID string) error

	// Close closes the client and releases any resources.
	Close() error
}

// ExecRequest represents a code execution request.
// It contains files to be created in the sandbox and steps/processes to execute.
type ExecRequest struct {
	// ID is a unique identifier for this job. If empty, the server will generate one.
	ID string

	// Files are the files to create in the sandbox environment.
	Files []File

	// Steps are the processes to execute sequentially.
	// Each step can access files from previous steps if persisted.
	Steps []Process
}

// File represents a file to be created in the sandbox.
type File struct {
	// Name is the filename (can include relative paths).
	Name string

	// Content is the file content.
	Content string
}

// Process represents a single execution step in the sandbox.
type Process struct {
	// Image is the container image name (must be available on server).
	// Example: "gcc:15-bookworm"
	Image string

	// Cmd is the command and arguments to execute.
	// Example: []string{"g++", "main.cpp", "-o", "main"}
	Cmd []string

	// Stdin is the standard input to provide to the process (optional).
	Stdin string

	// MemoryLimitMB is the memory limit in megabytes (0 = unlimited).
	MemoryLimitMB int64

	// TimeLimitMs is the time limit in milliseconds (0 = unlimited).
	TimeLimitMs uint64

	// ProcLimit is the maximum number of processes (0 = unlimited).
	ProcLimit int64

	// Files specifies which files to make available in this step.
	// References files by name from the Files array.
	Files []string

	// Persist specifies which output files to persist to the next step.
	// Only files listed here will be available to subsequent steps.
	Persist []string
}

// ExecResponse contains the execution results.
type ExecResponse struct {
	// ID is the unique job identifier.
	ID string

	// Reports contains one report per executed process/step.
	Reports []Report
}

// Report contains the execution results for a single process.
type Report struct {
	// Status indicates the execution status.
	Status Status

	// ExitCode is the process exit code.
	ExitCode int32

	// Signal is the signal that terminated the process (-1 if normal exit).
	Signal int32

	// Stdout is the standard output captured from the process.
	Stdout string

	// Stderr is the standard error captured from the process.
	Stderr string

	// CPUTime is the CPU time used in nanoseconds.
	CPUTime uint64

	// Memory is the peak memory usage in bytes.
	Memory uint64

	// WallTime is the wall clock time in milliseconds.
	WallTime int64

	// StartAt is the start timestamp in Unix nanoseconds.
	StartAt int64

	// FinishAt is the finish timestamp in Unix nanoseconds.
	FinishAt int64
}

// Status represents the execution status of a process.
type Status int32

const (
	StatusUnspecified         Status = 0
	StatusOK                  Status = 1
	StatusRuntimeError        Status = 2
	StatusTimeLimitExceeded   Status = 3
	StatusMemoryLimitExceeded Status = 4
	StatusOutputLimitExceeded Status = 5
	StatusTerminated          Status = 6
	StatusUnknown             Status = 7
	StatusSkipped             Status = 8
)

// String returns the string representation of the status.
func (s Status) String() string {
	switch s {
	case StatusUnspecified:
		return "UNSPECIFIED"
	case StatusOK:
		return "OK"
	case StatusRuntimeError:
		return "RUNTIME_ERROR"
	case StatusTimeLimitExceeded:
		return "TIME_LIMIT_EXCEEDED"
	case StatusMemoryLimitExceeded:
		return "MEMORY_LIMIT_EXCEEDED"
	case StatusOutputLimitExceeded:
		return "OUTPUT_LIMIT_EXCEEDED"
	case StatusTerminated:
		return "TERMINATED"
	case StatusUnknown:
		return "UNKNOWN"
	case StatusSkipped:
		return "SKIPPED"
	default:
		return "UNKNOWN"
	}
}

// ClientOptions contains configuration options for creating a client.
type ClientOptions struct {
	// Address is the server address. For HTTP, include the scheme (http://localhost:8000).
	// For gRPC, use host:port format (localhost:8001).
	Address string

	// Timeout is the default timeout for requests (default: 30 seconds).
	Timeout time.Duration

	// GRPCOptions contains additional gRPC-specific options (only used for gRPC client).
	GRPCOptions *GRPCOptions
}

// GRPCOptions contains gRPC-specific configuration options.
type GRPCOptions struct {
	// Insecure, when true, disables transport security (TLS).
	// Use this for testing or when connecting to insecure servers.
	Insecure bool

	// MaxMessageSize sets the maximum message size in bytes for gRPC (default: 4MB).
	MaxMessageSize int
}

// NewHTTPClient creates a new HTTP REST client for castletown.
//
// Example:
//
//	client, err := client.NewHTTPClient("http://localhost:8000", nil)
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
func NewHTTPClient(address string, opts *ClientOptions) (Client, error) {
	if opts == nil {
		opts = &ClientOptions{
			Address: address,
			Timeout: 30 * time.Second,
		}
	}
	if opts.Address == "" {
		opts.Address = address
	}
	if opts.Timeout == 0 {
		opts.Timeout = 30 * time.Second
	}

	return &httpClient{
		address: opts.Address,
		timeout: opts.Timeout,
	}, nil
}

// NewGRPCClient creates a new gRPC client for castletown.
//
// Example:
//
//	opts := &client.ClientOptions{
//	    GRPCOptions: &client.GRPCOptions{
//	        Insecure: true,
//	    },
//	}
//	client, err := client.NewGRPCClient("localhost:8001", opts)
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
func NewGRPCClient(address string, opts *ClientOptions) (Client, error) {
	if opts == nil {
		opts = &ClientOptions{
			Address: address,
			Timeout: 30 * time.Second,
			GRPCOptions: &GRPCOptions{
				Insecure:       true,
				MaxMessageSize: 4 * 1024 * 1024, // 4MB
			},
		}
	}
	if opts.Address == "" {
		opts.Address = address
	}
	if opts.Timeout == 0 {
		opts.Timeout = 30 * time.Second
	}
	if opts.GRPCOptions == nil {
		opts.GRPCOptions = &GRPCOptions{
			Insecure:       true,
			MaxMessageSize: 4 * 1024 * 1024,
		}
	}
	if opts.GRPCOptions.MaxMessageSize == 0 {
		opts.GRPCOptions.MaxMessageSize = 4 * 1024 * 1024
	}

	return newGRPCClient(address, opts)
}

// Helper functions to convert between client types and protobuf types

func toProtoFiles(files []File) []*pb.File {
	result := make([]*pb.File, len(files))
	for i, f := range files {
		result[i] = &pb.File{
			Name:    f.Name,
			Content: f.Content,
		}
	}
	return result
}

func toProtoProcesses(processes []Process) []*pb.Process {
	result := make([]*pb.Process, len(processes))
	for i, p := range processes {
		result[i] = &pb.Process{
			Image:         p.Image,
			Cmd:           p.Cmd,
			Stdin:         p.Stdin,
			MemoryLimitMb: p.MemoryLimitMB,
			TimeLimitMs:   p.TimeLimitMs,
			ProcLimit:     p.ProcLimit,
			Files:         p.Files,
			Persist:       p.Persist,
		}
	}
	return result
}

func fromProtoReports(reports []*pb.Report) []Report {
	result := make([]Report, len(reports))
	for i, r := range reports {
		result[i] = Report{
			Status:   Status(r.Status),
			ExitCode: r.ExitCode,
			Signal:   r.Signal,
			Stdout:   r.Stdout,
			Stderr:   r.Stderr,
			CPUTime:  r.CpuTime,
			Memory:   r.Memory,
			WallTime: r.WallTime,
			StartAt:  r.StartAt,
			FinishAt: r.FinishAt,
		}
	}
	return result
}
